<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ì „ìì„œëª… ê²€ì¦ ì‹¤í—˜</title>
</head>
<body>
  <h2>ğŸ” ì „ìì„œëª… ê²€ì¦ í…ŒìŠ¤íŠ¸</h2>
  <pre id="output">ê²€ì¦ ì¤‘...</pre>

  <script>
    async function loadAndVerify() {
      const output = document.getElementById('output');

      // 1. íŒŒì¼ ë¡œë“œ (ê°™ì€ ê²½ë¡œì— ìˆì„ ë•Œ ê¸°ì¤€)
      const jsRes = await fetch("my_module.js");
      const sigRes = await fetch("my_module.sig");
      const pubRes = await fetch("public.pem");

      const jsCode = await jsRes.text();
      const sig = await sigRes.arrayBuffer();
      const pubPem = await pubRes.text();

      // 2. ê³µê°œí‚¤ íŒŒì‹± (PEM â†’ ArrayBuffer)
      const pemToArrayBuffer = (pem) => {
        const b64 = pem.replace(/-----(BEGIN|END) PUBLIC KEY-----/g, "").replace(/\s+/g, "");
        const binary = atob(b64);
        const buffer = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) buffer[i] = binary.charCodeAt(i);
        return buffer.buffer;
      };

      const publicKey = await crypto.subtle.importKey(
        "spki",
        pemToArrayBuffer(pubPem),
        { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
        false,
        ["verify"]
      );

      // 3. ì„œëª… ê²€ì¦
      const encoder = new TextEncoder();
      const valid = await crypto.subtle.verify(
        "RSASSA-PKCS1-v1_5",
        publicKey,
        sig,
        encoder.encode(jsCode)
      );

      // 4. ê²°ê³¼ ì¶œë ¥
      if (valid) {
        output.textContent = "âœ… ì „ìì„œëª… ê²€ì¦ í†µê³¼! JS ì½”ë“œ ì‹¤í–‰ ì¤‘...";
        eval(jsCode);  // ì‹¤ì œ JS ì½”ë“œ ì‹¤í–‰
      } else {
        output.textContent = "âŒ ì „ìì„œëª… ê²€ì¦ ì‹¤íŒ¨! JS ì½”ë“œ ì‹¤í–‰ ì°¨ë‹¨ë¨.";
      }
    }

    loadAndVerify();
  </script>
</body>
</html>